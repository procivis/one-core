image: registry.gitlab.procivis.ch/procivis/one/one-operations/core-base:1.80.0-0.2

include:
  - project: 'procivis/one/one-operations'
    file: 'gitlab/aks-deploy.gitlab-ci.yml'


variables:
  DOCKER_DRIVER: overlay2
  DEPENDENCY_TRACK_PROJECT_NAME: "ONE-Core"
  CI_TAG_PATTERN: /^v[0-9]+\.[0-9]+\.[0-9]+-.+$/
  HELM_APP_NAME: one-core
  HELM_PATH: onecorechart

  # Required variables in GitLab config:
  # - AAD_SERVICE_PRINCIPAL_CLIENT_ID: Azure Active directory Application id. Use for RBAC SP kubelogin
  # - AAD_SERVICE_PRINCIPAL_CLIENT_SECRET: Application secret. Use for RBAC SP kubelogin
  # - AD_TENANT_ID: Azure Active Directory Tenant ID
  # - RESOURCE_GROUP: Azure Resource group where AKS deployed
  # - CLUSTER_NAME: AKS cluster name
  # - DEMO_RESOURCE_GROUP: Azure Resource group where AKS deployed
  # - DEMO_CLUSTER_NAME: AKS cluster name
  # - DOCKER_AUTH_CONFIG: Pull image from private repository
  # - BITRISE_API_ACCESS_TOKEN: Bitrise access token for IOS sdk build
  # - AZURE_STORAGE_ACCOUNT: storage account for sdk build upload
  # - AZURE_STORAGE_KEY: storage account key
  # - PGP_PRIVATE_KEY: helm-secrets
  # - DEPENDENCY_TRACK_BASE_URL: Base url for SBOM scanning
  # - DEPENDENCY_TRACK_API_KEY: Api key for api access

workflow:
  rules:
    - if: $CI_COMMIT_BRANCH
    - if: $CI_COMMIT_TAG

stages:
  - build
  - test
  - manual_e2e_tests
  - scan
  - publish
  - deploy
  - sdk_build
  - sdk_artifact
  - e2e_tests

.app_settings: &app_settings
  - APP_FLAVOR=$(echo $CI_COMMIT_TAG | sed -n "s/^v.*-\(.*\)$/\1/p")
  - APP_FLAVOR=${APP_FLAVOR:-procivis}
  - APP_VERSION=$(echo $CI_COMMIT_TAG | sed -n "s/^\(v.*\)-.*$/\1/p")
  - APP_VERSION=${APP_VERSION:-$CI_COMMIT_REF_SLUG-$CI_COMMIT_SHORT_SHA}
  - IMAGE_NAME=$CI_REGISTRY_IMAGE/$APP_FLAVOR
  - IMAGE_TAG=$IMAGE_NAME:$APP_VERSION
  - D_TRACK_PROJECT_VERSION=${CI_COMMIT_TAG:-$CI_COMMIT_REF_SLUG}
  - DEPLOY_IMAGE_TAG=$APP_VERSION

before_script:
  - *app_settings

.only_main_or_tag:
  rules:
    - if: $CI_COMMIT_TAG =~ $CI_TAG_PATTERN
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "release"

.only_main_or_tag_manual:
  when: manual
  rules:
    - if: $CI_COMMIT_TAG =~ $CI_TAG_PATTERN
      when: manual
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "release"
      when: manual

.only_main_or_tag_or_manual:
  rules:
    - !reference [.only_main_or_tag, rules]
    - when: manual

.manual_except_main_branch:
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: never
    - if: $CI_COMMIT_TAG =~ $CI_TAG_PATTERN
      when: never
    - when: on_success

.cargo_build:
  script:
    - cargo build --release
  artifacts:
    expire_in: 1 hour
    paths:
      - target/release/core-server

.cargo_tests:
  stage: test
  variables:
    # The default amount of codegen-units (256 for dev builds) vastly increases
    # the RAM usage during compilation, hence we limit it in CI
    RUSTFLAGS: "-C codegen-units=4"
  script:
    - cargo llvm-cov --no-clean --workspace --lcov --ignore-filename-regex=".*test.*\.rs$|tests/.*\.rs$" --output-path lcov.info
    - cargo llvm-cov report --cobertura --output-path cobertura.xml
    - cargo llvm-cov report
  coverage: '/^TOTAL\s+\d+\s+\d+\s+(?:\d+\.\d+)%\s+\d+\s+\d+\s+(?:\d+\.\d+)%\s+\d+\s+\d+\s+(\d+\.\d+)%/'
  artifacts:
    expire_in: 1 day
    when: always
    paths:
      - lcov.info
    reports:
      coverage_report:
        coverage_format: cobertura
        path: cobertura.xml

.docker_publish:
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker login $CI_REGISTRY -u $CI_REGISTRY_USER -p $CI_JOB_TOKEN
    - docker build -t $IMAGE_TAG -f docker/Dockerfile .
    - >
      if [ "$CI_COMMIT_REF_NAME" == "main" ] ; then
        docker image tag $IMAGE_TAG $IMAGE_NAME:latest
        docker push $IMAGE_NAME:latest
      fi
    - docker push $IMAGE_TAG
    - docker logout
    - echo "APP_VERSION=${APP_VERSION}" >> build.env
  artifacts:
    reports:
      dotenv: build.env

.run_e2e_tests:
  variables:
    CORE_IMAGE_TAG: ${APP_VERSION}
  trigger:
    project: procivis/one/one-e2e-tests
    branch: main
    strategy: depend

build:
  stage: build
  extends:
    - .cargo_build
    - .only_main_or_tag

tests:mariadb:
  extends:
    - .cargo_tests
  variables:
    MYSQL_PASSWORD: core_test
    MYSQL_USER: core_user
    MYSQL_DATABASE: core_db
    ONE_app__databaseUrl: "mysql://${MYSQL_USER}:${MYSQL_PASSWORD}@mariadb:3306/${MYSQL_DATABASE}"
  services:
    - alias: mariadb
      name: mariadb:10.9
      pull_policy: always
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_TAG =~ $CI_TAG_PATTERN
      when: always
    - if: $CI_COMMIT_BRANCH != "main"
      when: manual

tests:sqlite:
  extends:
    - .cargo_tests
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_TAG =~ $CI_TAG_PATTERN
      when: always
    - if: $CI_COMMIT_BRANCH != "main"
      when: always

linter:clippy:
  stage: test
  script:
    - cargo clippy --all-targets --message-format=json -- -D warnings > clippy.json
    - cargo clippy --package sql-data-provider --message-format=json -- -W clippy::expect_used -W clippy::panic -W clippy::unwrap_used >> clippy.json
  artifacts:
    expire_in: 1 day
    paths:
      - clippy.json

linter:rustfmt:
  stage: test
  script:
    - cargo fmt --all -- --check

linter:dependencies:
  stage: test
  script:
    - cargo deny --format json check 2> deny.json || true
    - cargo deny check
  artifacts:
    expire_in: 1 day
    when: always
    paths:
      - deny.json

sonarqube-check:
  stage: test
  needs:
    - job: linter:clippy
      artifacts: true
    - job: tests:mariadb
      artifacts: true
  image:
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar" # Defines the location of the analysis task cache
    GIT_DEPTH: "0" # Tells git to fetch all the branches of the project, required by the analysis task
  script:
    - sonar-scanner
  allow_failure: true
  extends:
    - .only_main_or_tag

publish:
  stage: publish
  dependencies: [build]
  extends:
    - .docker_publish
    - .only_main_or_tag

bitrise_ios_sdk:
  stage: sdk_build
  image: registry.gitlab.procivis.ch/procivis/one/one-operations/bitrise-builder:0.1.0
  needs: []
  dependencies: []
  variables:
    # ONE-wallet project on Bitrise
    BITRISE_PROJECT_SLUG: 6ee8c26f-6d7b-4bcb-8ddc-be1ba3cd2687
    BITRISE_WORKFLOW: iOS_Core_SDK
  script:
    - >
      /etc/gitrise.sh
      --access-token $BITRISE_API_ACCESS_TOKEN
      --slug $BITRISE_PROJECT_SLUG
      --workflow $BITRISE_WORKFLOW
      --commit "$CI_COMMIT_SHA"
      --env "CI_PIPELINE_ID:$CI_PIPELINE_ID"
      --output "artifacts"
  extends:
    - .only_main_or_tag_manual
  artifacts:
    paths:
      - artifacts
    expire_in: 10 days
  allow_failure: false

build_android_sdk:
  services:
    - docker:dind
  stage: sdk_build
  needs: []
  dependencies: []
  script:
    - export HOSTNAME=$(docker ps -ql)
    - export CROSS_CONTAINER_OPTS='--env="CI_PIPELINE_ID='$CI_PIPELINE_ID'"'
    - makers build_android
  artifacts:
    paths:
      - target/bindings/android
    expire_in: 5 days
  extends:
    - .only_main_or_tag_manual
  allow_failure: false

upload_sdk_artifacts:
  stage: sdk_artifact
  image: mcr.microsoft.com/azure-cli
  needs: [build_android_sdk, bitrise_ios_sdk]
  dependencies: [build_android_sdk, bitrise_ios_sdk]
  extends:
    - .only_main_or_tag
  variables:
    AZURE_CONTAINER_NAME: "core-sdk"
    ANDROID_BUILD_SOURCE_PATH: "target/bindings/android"
    ANDROID_CONTAINER_PATH: "android/${CI_PIPELINE_ID}"
    ANDROID_SDK_DEBUG_FILE: "onecore-debug.aar"
    ANDROID_SDK_RELEASE_FILE: "onecore-release.aar"
    IOS_CONTAINER_PATH: "ios/${CI_PIPELINE_ID}"
    IOS_BUILD_SOURCE_PATH: "artifacts"
    IOS_BUILD_FILE: "deploy.zip"
  script:
    # https://learn.microsoft.com/en-us/cli/azure/storage/blob?view=azure-cli-latest#az-storage-blob-download
    - ANDROID_CONTAINER_PATH_DEBUG=$ANDROID_CONTAINER_PATH/$ANDROID_SDK_DEBUG_FILE
    - ANDROID_CONTAINER_PATH_RELEASE=$ANDROID_CONTAINER_PATH/$ANDROID_SDK_RELEASE_FILE
    - IOS_CONTAINER_PATH=$IOS_CONTAINER_PATH/$IOS_BUILD_FILE
    # Upload Android debug file
    - az storage blob upload --overwrite -c $AZURE_CONTAINER_NAME -n $ANDROID_CONTAINER_PATH_DEBUG -f $ANDROID_BUILD_SOURCE_PATH/$ANDROID_SDK_DEBUG_FILE
    # Upload Android release file
    - az storage blob upload --overwrite -c $AZURE_CONTAINER_NAME -n $ANDROID_CONTAINER_PATH_RELEASE -f $ANDROID_BUILD_SOURCE_PATH/$ANDROID_SDK_RELEASE_FILE
    # Upload IOS zip file
    - az storage blob upload --overwrite -c $AZURE_CONTAINER_NAME -n $IOS_CONTAINER_PATH -f $IOS_BUILD_SOURCE_PATH/$IOS_BUILD_FILE
    - >
      cat <<-EOM
        =========================
        SDK Download links:
        -------------------------
        Android DEBUG: https://onetfstatestorage.blob.core.windows.net/$AZURE_CONTAINER_NAME/$ANDROID_CONTAINER_PATH_DEBUG
        SHA-1: $(sha1sum -b $ANDROID_BUILD_SOURCE_PATH/$ANDROID_SDK_DEBUG_FILE | cut -d " " -f1)
        -------------------------
        Android RELEASE: https://onetfstatestorage.blob.core.windows.net/$AZURE_CONTAINER_NAME/$ANDROID_CONTAINER_PATH_RELEASE
        SHA-1: $(sha1sum -b $ANDROID_BUILD_SOURCE_PATH/$ANDROID_SDK_RELEASE_FILE | cut -d " " -f1)
        -------------------------
        iOS: https://onetfstatestorage.blob.core.windows.net/$AZURE_CONTAINER_NAME/$IOS_CONTAINER_PATH
        SHA-1: $(sha1sum -b $IOS_BUILD_SOURCE_PATH/$IOS_BUILD_FILE | cut -d " " -f1)
        =========================
      EOM

generate_binding_files:
  stage: sdk_build
  needs:
    - build
    - tests:mariadb
  script:
    - makers generateuniffi_android
    - makers generateuniffi_ios
  artifacts:
    paths:
      - target/uniffi/android/java/ch/procivis/one/core/one_core.kt
      - target/uniffi/ios/one_core.swift
    expire_in: 10 days
  extends:
    - .only_main_or_tag

test_e2e:
  stage: e2e_tests
  needs:
    - job: publish
      artifacts: true
  extends:
    - .run_e2e_tests
    - .only_main_or_tag

deploy:dev:
  stage: deploy
  extends:
    - .deploy_k8s:sops
  resource_group: core-dev
  variables:
    VALUES_PATH: values/dev
    K8S_NAMESPACE: default
  rules:
    - if: $CI_COMMIT_REF_NAME == "main"

deploy:test:
  stage: deploy
  extends:
    - .deploy_k8s:sops
  variables:
    VALUES_PATH: values/test
    K8S_NAMESPACE: one-test
  rules:
    - if: $CI_COMMIT_TAG =~ $CI_TAG_PATTERN
      when: on_success

deploy:demo:
  stage: deploy
  extends:
    - .deploy_k8s:sops
  variables:
    VALUES_PATH: values/demo
    K8S_NAMESPACE: default
  before_script:
    - *app_settings
    - RESOURCE_GROUP=$DEMO_RESOURCE_GROUP
    - CLUSTER_NAME=$DEMO_CLUSTER_NAME
  rules:
    - if: $CI_COMMIT_TAG =~ $CI_TAG_PATTERN
      when: manual

run_e2e_tests:
  stage: manual_e2e_tests
  when: manual
  needs: [tests:sqlite]
  script:
    - echo "Job for trigger manual e2e tests"
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_TAG =~ $CI_TAG_PATTERN
      when: never
    - when: manual

e2e:build:
  stage: manual_e2e_tests
  needs:
    - job: run_e2e_tests
  extends:
    - .cargo_build
    - .manual_except_main_branch

e2e:publish:
  stage: manual_e2e_tests
  needs:
    - job: e2e:build
  dependencies: [e2e:build]
  extends:
    - .docker_publish
    - .manual_except_main_branch

e2e:trigger_tests:
  stage: manual_e2e_tests
  needs:
    - job: e2e:publish
      artifacts: true
  extends:
    - .run_e2e_tests
    - .manual_except_main_branch

dependency_track:upload-bom:
  stage: scan
  variables:
    D_TRACK_PATH: ${DEPENDENCY_TRACK_BASE_URL}/api/v1/bom
    SBOM_FILE_PATH: "merged_sbom.json"
    SBOM_FILES: >-
      apps/core-server/core-server.cdx.json
      apps/migration/migration.cdx.json
      lib/one-core/one-core.cdx.json
      lib/shared-types/shared-types.cdx.json
      lib/sql-data-provider/sql-data-provider.cdx.json
      platforms/uniffi-bindgen/uniffi-bindgen.cdx.json
      platforms/uniffi/one-core-uniffi.cdx.json
  extends:
    - .only_main_or_tag
  script:
    - cargo cyclonedx -f json
    - cyclonedx-cli merge --input-files ${SBOM_FILES} --input-format=json --output-format=json --group apps > ${SBOM_FILE_PATH}
    - file_content=$(base64 -i $SBOM_FILE_PATH)
    - |
      curl -i --fail -X PUT \
        -H "Content-Type: application/json" \
        -H "X-API-Key: ${DEPENDENCY_TRACK_API_KEY}" \
        --data @- ${D_TRACK_PATH} << EOF
      {
        "projectName": "${DEPENDENCY_TRACK_PROJECT_NAME}",
        "projectVersion": "${D_TRACK_PROJECT_VERSION}",
        "autoCreate": true,
        "bom": "${file_content}"
      }
      EOF

.dTrack_metrics: &dTrack_metrics
  - base_url=${DEPENDENCY_TRACK_BASE_URL}/api/v1/project/lookup
  - url="${base_url}?name=${DEPENDENCY_TRACK_PROJECT_NAME}&version=${D_TRACK_PROJECT_VERSION}"
  - echo "URL=$url"
  - >
    result=$(curl -X GET "${url}" \
      -H "X-Api-Key: ${DEPENDENCY_TRACK_API_KEY}" \
      -H "Accept: application/json")
  - metrics=$(echo $result | jq -r .metrics)
  - echo "Dependency Track Project Version metrics=${metrics}"

dependency_track:policy_violations:
  stage: scan
  allow_failure: true
  needs:
    - job: dependency_track:upload-bom
  extends:
    - .only_main_or_tag
  script:
    - *dTrack_metrics
    - violated_licences=$(echo ${metrics} | jq -r .policyViolationsFail)
    - echo "Count of violated_licences=${violated_licences}"
    - >
      if [[ ${violated_licences} -gt 0 ]]; then
        echo "Violated licences more that 0."
        exit 1;
      fi

dependency_track:metrics:
  stage: scan
  allow_failure: true
  needs:
    - job: dependency_track:upload-bom
  extends:
    - .only_main_or_tag
  script:
    - *dTrack_metrics
    - critical=$(echo ${metrics} | jq -r .critical)
    - high=$(echo ${metrics} | jq -r .high)
    - echo "Critical vulnerabilities=${critical}"
    - echo "High vulnerabilities=${high}"
    - >
      if [[ ${critical} -gt 0  || ${high} -gt 0  ]]; then
          echo "Lib vulnerabilities more that 0."
          exit 1;
      fi

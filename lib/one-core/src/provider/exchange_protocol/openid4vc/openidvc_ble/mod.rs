use crate::provider::bluetooth_low_energy::{low_level::dto::DeviceInfo, BleError};
use aes_gcm::aead::{Aead, Payload};
use aes_gcm::{Aes256Gcm, KeyInit};
use anyhow::{anyhow, Context, Result};
use futures::Stream;
use futures::TryStreamExt;
use hkdf::Hkdf;
use one_providers::crypto::imp::hasher::sha256::SHA256;
use one_providers::crypto::Hasher;
use rand::rngs::OsRng;
use serde::de::DeserializeOwned;
use serde::{Deserialize, Serialize};
use std::pin::Pin;
use x25519_dalek::{EphemeralSecret, PublicKey};

pub mod oidc_ble_holder;
pub mod oidc_ble_verifier;

// https://openid.bitbucket.io/connect/openid-4-verifiable-presentations-over-ble-1_0.html#section-10
pub const SERVICE_UUID: &str = "00000001-5026-444A-9E0E-D6F2450F3A77";
pub const REQUEST_SIZE_UUID: &str = "00000004-5026-444A-9E0E-D6F2450F3A77";
pub const PRESENTATION_REQUEST_UUID: &str = "00000005-5026-444A-9E0E-D6F2450F3A77";
pub const IDENTITY_UUID: &str = "00000006-5026-444A-9E0E-D6F2450F3A77";
pub const CONTENT_SIZE_UUID: &str = "00000007-5026-444A-9E0E-D6F2450F3A77";
pub const SUBMIT_VC_UUID: &str = "00000008-5026-444A-9E0E-D6F2450F3A77";
pub const TRANSFER_SUMMARY_REQUEST_UUID: &str = "00000009-5026-444A-9E0E-D6F2450F3A77";
pub const TRANSFER_SUMMARY_REPORT_UUID: &str = "0000000A-5026-444A-9E0E-D6F2450F3A77";
pub const DISCONNECT_UUID: &str = "0000000B-5026-444A-9E0E-D6F2450F3A77";

pub type MessageSize = u16;

// https://openid.bitbucket.io/connect/openid-4-verifiable-presentations-over-ble-1_0.html#name-transfer-summary-report
type TransferSummaryReport = Vec<u16>;

// https://openid.bitbucket.io/connect/openid-4-verifiable-presentations-over-ble-1_0.html#section-5.3
#[derive(Clone, Debug)]
pub struct IdentityRequest {
    pub key: [u8; 32],
    pub nonce: [u8; 12],
}

impl IdentityRequest {
    pub fn encode(self) -> Vec<u8> {
        self.key
            .iter()
            .chain(&self.nonce)
            .copied()
            .collect::<Vec<u8>>()
    }
}

type BLEStream = Pin<Box<dyn Stream<Item = Result<Vec<u8>, BleError>> + Send>>;
#[async_trait::async_trait]
pub trait BLEParse<T, Error> {
    async fn parse(self) -> Result<T, Error>;
}

#[async_trait::async_trait]
impl BLEParse<TransferSummaryReport, anyhow::Error> for BLEStream {
    async fn parse(mut self) -> Result<TransferSummaryReport> {
        let data = self
            .try_next()
            .await?
            .ok_or(anyhow!("Failed to read transfer summary report"))?;

        data.chunks(2)
            .map(|chunk| {
                Ok(u16::from_be_bytes(chunk.try_into().map_err(|_| {
                    anyhow!("Failed to convert chunk to [u8; 2]")
                })?))
            })
            .collect()
    }
}

#[async_trait::async_trait]
impl BLEParse<IdentityRequest, anyhow::Error> for BLEStream {
    async fn parse(mut self) -> Result<IdentityRequest> {
        let data = self
            .try_next()
            .await?
            .ok_or(anyhow!("Failed to read identity request"))?;

        let arr: [u8; 44] = data
            .try_into()
            .map_err(|_| anyhow!("Failed to convert vec to [u8; 44]"))?;

        let (key, nonce) = arr.split_at(32);

        Ok(IdentityRequest {
            key: key
                .try_into()
                .context("Failed to parse key from identity request")?,
            nonce: nonce
                .try_into()
                .context("Failed to parse nonce from identity request")?,
        })
    }
}

#[async_trait::async_trait]
impl BLEParse<MessageSize, anyhow::Error> for BLEStream {
    async fn parse(mut self) -> Result<u16> {
        let data = self
            .try_next()
            .await?
            .ok_or(anyhow!("Failed to read message size"))?;

        let arr = data
            .try_into()
            .map_err(|_| anyhow!("cannot convert request to [u8; 2]"))?;

        Ok(u16::from_be_bytes(arr))
    }
}

#[derive(Clone, Serialize, Deserialize, Debug)]
pub(super) struct BLEPeer {
    pub device_info: DeviceInfo,
    sender_aes_key: [u8; 32],
    receiver_aes_key: [u8; 32],
    nonce: [u8; 12],
}

impl BLEPeer {
    pub fn new(
        device_info: DeviceInfo,
        sender_aes_key: [u8; 32],
        receiver_aes_key: [u8; 32],
        nonce: [u8; 12],
    ) -> Self {
        Self {
            device_info,
            sender_aes_key,
            receiver_aes_key,
            nonce,
        }
    }

    pub fn encrypt<T>(&self, data: T) -> anyhow::Result<Vec<u8>>
    where
        T: Serialize,
    {
        let cipher = Aes256Gcm::new(&self.sender_aes_key.into());
        let plaintext =
            serde_json::to_vec(&data).map_err(|e| anyhow!("serialization error: {e}"))?;

        // https://openid.bitbucket.io/connect/openid-4-verifiable-presentations-over-ble-1_0.html#section-6.1
        // The IV is the random nonce generated by the wallet
        // The AAD used as input for the GCM function MUST be an empty string
        cipher
            .encrypt(
                &self.nonce.into(),
                Payload {
                    aad: &[],
                    msg: &plaintext,
                },
            )
            .map_err(|e| anyhow!("AES encryption error: {e}"))
    }

    pub fn decrypt<T>(&self, ciphertext: &[u8]) -> anyhow::Result<T>
    where
        T: DeserializeOwned,
    {
        let cipher = Aes256Gcm::new(&self.receiver_aes_key.into());
        let decrypted_payload = cipher
            .decrypt(&self.nonce.into(), ciphertext)
            .map_err(|e| anyhow!("AES decryption error: {e}"));

        serde_json::from_slice(&decrypted_payload?)
            .map_err(|e| anyhow!("deserialization error: {e}"))
    }
}

// Ephemeral x25519 key pair, discarded after the symmetric keys are derived
pub struct KeyAgreementKey {
    secret_key: EphemeralSecret,
}

impl KeyAgreementKey {
    pub fn new_random() -> Self {
        Self {
            secret_key: EphemeralSecret::random_from_rng(OsRng),
        }
    }

    // https://openid.bitbucket.io/connect/openid-4-verifiable-presentations-over-ble-1_0.html#name-session-key-computation
    // Two keys need to be derived
    // Messages to the wallet are encrypted using the session key SKWallet
    // Messages to the verifier are encrypted using the session key SKVerifier
    pub fn derive_session_secrets(
        self,
        their_public_key: [u8; 32],
        nonce: [u8; 12],
    ) -> Result<([u8; 32], [u8; 32])> {
        let their_public_key = x25519_dalek::PublicKey::from(their_public_key);
        let z_ab = self.secret_key.diffie_hellman(&their_public_key);
        let hasher = SHA256 {};

        // See https://github.com/openid/openid4vp_ble/issues/47#issuecomment-1991006348
        let salt = hasher
            .hash(&nonce)
            .map_err(|e| anyhow!("Failed to generate salt: {e}"))?;

        let mut wallet_key: [u8; 32] = [0; 32];
        let mut verifier_key: [u8; 32] = [0; 32];

        Hkdf::<sha2::Sha256>::new(Some(&salt), z_ab.as_bytes())
            .expand("SKWallet".as_bytes(), &mut wallet_key)
            .map_err(|e| anyhow!("Failed to expand session key: {e}"))?;

        Hkdf::<sha2::Sha256>::new(Some(&salt), z_ab.as_bytes())
            .expand("SKVerifier".as_bytes(), &mut verifier_key)
            .map_err(|e| anyhow!("Failed to expand session key: {e}"))?;

        Ok((wallet_key, verifier_key))
    }

    pub fn public_key_bytes(&self) -> [u8; 32] {
        PublicKey::from(&self.secret_key).to_bytes()
    }
}

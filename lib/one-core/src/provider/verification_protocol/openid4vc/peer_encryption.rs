use aes_gcm::aead::consts::U32;
use aes_gcm::aead::generic_array::GenericArray;
use aes_gcm::aead::{Aead, Payload};
use aes_gcm::{Aes256Gcm, KeyInit};
use anyhow::Context;
use secrecy::{ExposeSecret, SecretSlice};
use serde::de::DeserializeOwned;
use serde::{Deserialize, Serialize};

use crate::common_mapper::secret_slice;

#[derive(Clone, Serialize, Deserialize, Debug)]
pub struct PeerEncryption {
    #[serde(with = "secret_slice")]
    sender_aes_key: SecretSlice<u8>,
    #[serde(with = "secret_slice")]
    receiver_aes_key: SecretSlice<u8>,
    nonce: [u8; 12],
}

impl PeerEncryption {
    pub fn new(
        sender_aes_key: SecretSlice<u8>,
        receiver_aes_key: SecretSlice<u8>,
        nonce: [u8; 12],
    ) -> Self {
        Self {
            sender_aes_key,
            receiver_aes_key,
            nonce,
        }
    }

    pub fn encrypt<T>(&self, data: &T) -> anyhow::Result<Vec<u8>>
    where
        T: Serialize,
    {
        let cipher = Aes256Gcm::new(GenericArray::<u8, U32>::from_slice(
            self.sender_aes_key.expose_secret(),
        ));
        let plaintext = serde_json::to_vec(data).context("serialization error")?;

        // https://openid.bitbucket.io/connect/openid-4-verifiable-presentations-over-ble-1_0.html#section-6.1
        // The IV is the random nonce generated by the wallet
        // The AAD used as input for the GCM function MUST be an empty string
        cipher
            .encrypt(
                &self.nonce.into(),
                Payload {
                    aad: &[],
                    msg: &plaintext,
                },
            )
            .context("AES encryption error")
    }

    pub fn decrypt<T>(&self, ciphertext: &[u8]) -> anyhow::Result<T>
    where
        T: DeserializeOwned,
    {
        let cipher = Aes256Gcm::new(GenericArray::<u8, U32>::from_slice(
            self.receiver_aes_key.expose_secret(),
        ));
        let decrypted_payload = cipher
            .decrypt(&self.nonce.into(), ciphertext)
            .context("AES decryption error");

        serde_json::from_slice(&decrypted_payload?).context("deserialization error")
    }
}

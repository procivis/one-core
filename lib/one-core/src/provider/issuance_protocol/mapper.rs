use std::sync::Arc;

use indexmap::IndexMap;
use shared_types::{BlobId, IdentifierId};
use time::OffsetDateTime;
use uuid::Uuid;

use crate::config::core_config::KeyAlgorithmType;
use crate::model::credential::{Clearable, CredentialStateEnum, UpdateCredentialRequest};
use crate::model::did::{Did, DidType, KeyRole, RelatedKey};
use crate::model::identifier::{Identifier, IdentifierState, IdentifierType};
use crate::model::interaction::{Interaction, InteractionType};
use crate::model::key::Key;
use crate::model::organisation::Organisation;
use crate::provider::did_method::DidKeys;
use crate::provider::did_method::provider::DidMethodProvider;
use crate::provider::issuance_protocol::HolderBindingInput;
use crate::provider::issuance_protocol::error::IssuanceProtocolError;
use crate::provider::issuance_protocol::model::OpenID4VCIProofTypeSupported;
use crate::provider::key_algorithm::provider::KeyAlgorithmProvider;
use crate::provider::key_security_level::provider::KeySecurityLevelProvider;
use crate::provider::key_storage::KeyStorage;
use crate::provider::key_storage::provider::KeyProvider;
use crate::repository::did_repository::DidRepository;
use crate::repository::identifier_repository::IdentifierRepository;
use crate::repository::key_repository::KeyRepository;

pub(super) fn get_issued_credential_update(
    credential_blob_id: BlobId,
    holder_identifier_id: IdentifierId,
) -> UpdateCredentialRequest {
    UpdateCredentialRequest {
        state: Some(CredentialStateEnum::Accepted),
        suspend_end_date: Clearable::DontTouch,
        holder_identifier_id: Some(holder_identifier_id),
        credential_blob_id: Some(credential_blob_id),
        ..Default::default()
    }
}

pub(crate) fn interaction_from_handle_invitation(
    data: Option<Vec<u8>>,
    now: OffsetDateTime,
    organisation: Option<Organisation>,
) -> Interaction {
    Interaction {
        id: Uuid::new_v4(),
        created_date: now,
        last_modified: now,
        data,
        organisation,
        nonce_id: None,
        interaction_type: InteractionType::Issuance,
    }
}

#[expect(clippy::too_many_arguments)]
pub(super) async fn autogenerate_holder_binding(
    cryptographic_binding_methods_supported: Option<&Vec<String>>,
    proof_types_supported: Option<&IndexMap<String, OpenID4VCIProofTypeSupported>>,
    organisation: &Organisation,
    key_provider: &dyn KeyProvider,
    key_algorithm_provider: &dyn KeyAlgorithmProvider,
    key_security_level_provider: &dyn KeySecurityLevelProvider,
    did_method_provider: &dyn DidMethodProvider,
    key_repository: &dyn KeyRepository,
    did_repository: &dyn DidRepository,
    identifier_repository: &dyn IdentifierRepository,
) -> Result<HolderBindingInput, IssuanceProtocolError> {
    let PickedKeyConfig {
        key_storage_id,
        key_storage,
        key_algorithm,
    } = pick_key_configuration(
        proof_types_supported,
        key_provider,
        key_algorithm_provider,
        key_security_level_provider,
    )?;

    let key_id = Uuid::new_v4().into();
    let key = key_storage
        .generate(key_id, key_algorithm)
        .await
        .map_err(|e| IssuanceProtocolError::BindingAutogenerationFailure(e.to_string()))?;
    let key = Key {
        id: key_id,
        created_date: OffsetDateTime::now_utc(),
        last_modified: OffsetDateTime::now_utc(),
        public_key: key.public_key,
        name: format!("autogenerated-{key_id}"),
        key_reference: key.key_reference,
        storage_type: key_storage_id,
        key_type: key_algorithm.to_string(),
        organisation: Some(organisation.to_owned()),
    };
    key_repository
        .create_key(key.to_owned())
        .await
        .map_err(|e| IssuanceProtocolError::BindingAutogenerationFailure(e.to_string()))?;

    // generate did only if jwk binding method is not supported by the issuer
    let did = if let Some(methods) = cryptographic_binding_methods_supported
        && !methods.contains(&"jwk".to_string())
    {
        let supported_method = did_method_provider
            .supported_method_names()
            .into_iter()
            .find(|supported_method| methods.contains(&format!("did:{supported_method}")))
            .ok_or(IssuanceProtocolError::BindingAutogenerationFailure(
                format!("No supported binding method, methods:{methods:?}"),
            ))?;

        let (did_method_id, did_method) = did_method_provider
            .get_did_method_by_method_name(&supported_method)
            .ok_or(IssuanceProtocolError::BindingAutogenerationFailure(
                format!("Did method not available:{supported_method}"),
            ))?;

        let did_id = Uuid::new_v4().into();
        let did = did_method
            .create(
                Some(did_id),
                &None,
                Some(DidKeys {
                    authentication: vec![key.to_owned()],
                    assertion_method: vec![key.to_owned()],
                    key_agreement: vec![key.to_owned()],
                    capability_invocation: vec![key.to_owned()],
                    capability_delegation: vec![key.to_owned()],
                    ..Default::default()
                }),
            )
            .await
            .map_err(|e| IssuanceProtocolError::BindingAutogenerationFailure(e.to_string()))?;
        let related_key = RelatedKey {
            role: KeyRole::Authentication,
            reference: did_method
                .get_reference_for_key(&key)
                .map_err(|e| IssuanceProtocolError::BindingAutogenerationFailure(e.to_string()))?,
            key: key.clone(),
        };
        let did = Did {
            id: did_id,
            created_date: OffsetDateTime::now_utc(),
            last_modified: OffsetDateTime::now_utc(),
            name: format!("autogenerated-{did_id}"),
            did: did.did,
            did_method: did_method_id,
            did_type: DidType::Local,
            deactivated: false,
            log: did.log,
            keys: Some(vec![
                related_key.to_owned(),
                RelatedKey {
                    role: KeyRole::AssertionMethod,
                    ..related_key.to_owned()
                },
                RelatedKey {
                    role: KeyRole::KeyAgreement,
                    ..related_key.to_owned()
                },
                RelatedKey {
                    role: KeyRole::CapabilityInvocation,
                    ..related_key.to_owned()
                },
                RelatedKey {
                    role: KeyRole::CapabilityDelegation,
                    ..related_key.to_owned()
                },
            ]),
            organisation: Some(organisation.to_owned()),
        };
        did_repository
            .create_did(did.to_owned())
            .await
            .map_err(|e| IssuanceProtocolError::BindingAutogenerationFailure(e.to_string()))?;

        Some(did)
    } else {
        None
    };

    let identifier_id = Uuid::new_v4().into();
    let identifier = Identifier {
        id: identifier_id,
        created_date: OffsetDateTime::now_utc(),
        last_modified: OffsetDateTime::now_utc(),
        name: format!("autogenerated-{identifier_id}"),
        r#type: if did.is_some() {
            IdentifierType::Did
        } else {
            IdentifierType::Key
        },
        is_remote: false,
        state: IdentifierState::Active,
        deleted_at: None,
        organisation: Some(organisation.to_owned()),
        key: did.is_none().then_some(key.clone()),
        certificates: None,
        did,
    };
    identifier_repository
        .create(identifier.to_owned())
        .await
        .map_err(|e| IssuanceProtocolError::BindingAutogenerationFailure(e.to_string()))?;

    Ok(HolderBindingInput { identifier, key })
}

struct PickedKeyConfig {
    key_storage_id: String,
    key_storage: Arc<dyn KeyStorage>,
    key_algorithm: KeyAlgorithmType,
}

fn pick_key_configuration(
    proof_types_supported: Option<&IndexMap<String, OpenID4VCIProofTypeSupported>>,
    key_provider: &dyn KeyProvider,
    key_algorithm_provider: &dyn KeyAlgorithmProvider,
    key_security_level_provider: &dyn KeySecurityLevelProvider,
) -> Result<PickedKeyConfig, IssuanceProtocolError> {
    let issuer_proof_config = proof_types_supported
        .as_ref()
        .and_then(|proof_types| proof_types.get("jwt"));

    let issuer_accepted_security_levels = issuer_proof_config.and_then(|proof_type| {
        proof_type
            .key_attestations_required
            .as_ref()
            .map(|kar| &kar.key_storage)
    });

    let issuer_accepted_algorithms = issuer_proof_config.map(|proof_type| {
        proof_type
            .proof_signing_alg_values_supported
            .iter()
            .filter_map(|alg| key_algorithm_provider.key_algorithm_from_jose_alg(alg))
            .map(|(alg, _)| alg)
            .collect::<Vec<_>>()
    });

    for (_, security_level) in key_security_level_provider.ordered_by_priority() {
        if issuer_accepted_security_levels
            .as_ref()
            .is_some_and(|issuer_accepted_levels| {
                !security_level
                    .get_capabilities()
                    .openid_security_level
                    .iter()
                    .any(|level| issuer_accepted_levels.contains(level))
            })
        {
            continue;
        }

        for key_storage_id in security_level.get_key_storages() {
            let Some(storage) = key_provider.get_key_storage(key_storage_id) else {
                continue;
            };

            for (algorithm, _) in key_algorithm_provider.ordered_by_holder_priority() {
                if !storage.get_capabilities().algorithms.contains(&algorithm) {
                    continue;
                }

                if let Some(issuer_accepted_algorithms) = &issuer_accepted_algorithms
                    && !issuer_accepted_algorithms.contains(&algorithm)
                {
                    continue;
                }

                return Ok(PickedKeyConfig {
                    key_storage_id: key_storage_id.to_owned(),
                    key_storage: storage,
                    key_algorithm: algorithm,
                });
            }
        }
    }

    Err(IssuanceProtocolError::BindingAutogenerationFailure(
        format!(
            "Could not find a proper key storage, issuer_accepted_security_levels:{issuer_accepted_security_levels:?}, issuer_accepted_algorithms:{issuer_accepted_algorithms:?}"
        ),
    ))
}

use std::sync::Arc;

use indexmap::IndexMap;
use shared_types::{BlobId, IdentifierId};
use time::OffsetDateTime;
use uuid::Uuid;

use crate::config::core_config::KeyAlgorithmType;
use crate::model::credential::{Clearable, CredentialStateEnum, UpdateCredentialRequest};
use crate::model::interaction::{Interaction, InteractionType};
use crate::model::key::Key;
use crate::model::organisation::Organisation;
use crate::proto::identifier_creator::{CreateLocalIdentifierRequest, IdentifierCreator};
use crate::provider::did_method::provider::DidMethodProvider;
use crate::provider::issuance_protocol::HolderBindingInput;
use crate::provider::issuance_protocol::error::IssuanceProtocolError;
use crate::provider::issuance_protocol::model::OpenID4VCIProofTypeSupported;
use crate::provider::key_algorithm::provider::KeyAlgorithmProvider;
use crate::provider::key_security_level::provider::KeySecurityLevelProvider;
use crate::provider::key_storage::KeyStorage;
use crate::provider::key_storage::provider::KeyProvider;
use crate::repository::key_repository::KeyRepository;
use crate::service::did::dto::{CreateDidRequestDTO, CreateDidRequestKeysDTO};

pub(super) fn get_issued_credential_update(
    credential_blob_id: BlobId,
    holder_identifier_id: IdentifierId,
) -> UpdateCredentialRequest {
    UpdateCredentialRequest {
        state: Some(CredentialStateEnum::Accepted),
        suspend_end_date: Clearable::DontTouch,
        holder_identifier_id: Some(holder_identifier_id),
        credential_blob_id: Some(credential_blob_id),
        ..Default::default()
    }
}

pub(crate) fn interaction_from_handle_invitation(
    data: Option<Vec<u8>>,
    now: OffsetDateTime,
    organisation: Option<Organisation>,
) -> Interaction {
    Interaction {
        id: Uuid::new_v4(),
        created_date: now,
        last_modified: now,
        data,
        organisation,
        nonce_id: None,
        interaction_type: InteractionType::Issuance,
    }
}

#[expect(clippy::too_many_arguments)]
pub(super) async fn autogenerate_holder_binding(
    cryptographic_binding_methods_supported: Option<&Vec<String>>,
    proof_types_supported: Option<&IndexMap<String, OpenID4VCIProofTypeSupported>>,
    organisation: &Organisation,
    key_provider: &dyn KeyProvider,
    key_algorithm_provider: &dyn KeyAlgorithmProvider,
    key_security_level_provider: &dyn KeySecurityLevelProvider,
    did_method_provider: &dyn DidMethodProvider,
    key_repository: &dyn KeyRepository,
    identifier_creator: &dyn IdentifierCreator,
) -> Result<HolderBindingInput, IssuanceProtocolError> {
    let PickedKeyConfig {
        key_storage_id,
        key_storage,
        key_algorithm,
    } = pick_key_configuration(
        proof_types_supported,
        key_provider,
        key_algorithm_provider,
        key_security_level_provider,
    )?;

    let key_id = Uuid::new_v4().into();
    let key = key_storage
        .generate(key_id, key_algorithm)
        .await
        .map_err(|e| IssuanceProtocolError::BindingAutogenerationFailure(e.to_string()))?;

    let now = OffsetDateTime::now_utc();
    let key = Key {
        id: key_id,
        created_date: now,
        last_modified: now,
        public_key: key.public_key,
        name: format!("autogenerated-{key_id}"),
        key_reference: key.key_reference,
        storage_type: key_storage_id,
        key_type: key_algorithm.to_string(),
        organisation: Some(organisation.to_owned()),
    };
    key_repository
        .create_key(key.to_owned())
        .await
        .map_err(|e| IssuanceProtocolError::BindingAutogenerationFailure(e.to_string()))?;

    // generate did only if jwk binding method is not supported by the issuer
    if let Some(methods) = cryptographic_binding_methods_supported
        && !methods.contains(&"jwk".to_string())
    {
        return generate_holder_binding_did(
            methods,
            key,
            organisation,
            did_method_provider,
            identifier_creator,
        )
        .await;
    };

    let identifier = identifier_creator
        .create_local_identifier(
            format!("autogenerated-key-{}", key.id),
            CreateLocalIdentifierRequest::Key(key.to_owned()),
            organisation.to_owned(),
        )
        .await
        .map_err(|e| IssuanceProtocolError::BindingAutogenerationFailure(e.to_string()))?;

    Ok(HolderBindingInput { identifier, key })
}

async fn generate_holder_binding_did(
    cryptographic_binding_methods_supported: &Vec<String>,
    key: Key,
    organisation: &Organisation,
    did_method_provider: &dyn DidMethodProvider,
    identifier_creator: &dyn IdentifierCreator,
) -> Result<HolderBindingInput, IssuanceProtocolError> {
    let supported_method = did_method_provider
        .supported_method_names()
        .into_iter()
        .find(|supported_method| {
            cryptographic_binding_methods_supported.contains(&format!("did:{supported_method}"))
        })
        .ok_or(IssuanceProtocolError::BindingAutogenerationFailure(
            format!(
                "No supported binding method, methods:{cryptographic_binding_methods_supported:?}"
            ),
        ))?;

    let (did_method_id, _) = did_method_provider
        .get_did_method_by_method_name(&supported_method)
        .ok_or(IssuanceProtocolError::BindingAutogenerationFailure(
            format!("Did method not available:{supported_method}"),
        ))?;

    let key_id = key.id;
    let name = format!("autogenerated-did-{key_id}");
    let identifier = identifier_creator
        .create_local_identifier(
            name.to_owned(),
            CreateLocalIdentifierRequest::Did(CreateDidRequestDTO {
                name,
                organisation_id: organisation.id,
                did_method: did_method_id,
                keys: CreateDidRequestKeysDTO {
                    authentication: vec![key_id],
                    assertion_method: vec![key_id],
                    key_agreement: vec![key_id],
                    capability_invocation: vec![key_id],
                    capability_delegation: vec![key_id],
                },
                params: None,
            }),
            organisation.to_owned(),
        )
        .await
        .map_err(|e| IssuanceProtocolError::BindingAutogenerationFailure(e.to_string()))?;

    Ok(HolderBindingInput { identifier, key })
}

struct PickedKeyConfig {
    key_storage_id: String,
    key_storage: Arc<dyn KeyStorage>,
    key_algorithm: KeyAlgorithmType,
}

fn pick_key_configuration(
    proof_types_supported: Option<&IndexMap<String, OpenID4VCIProofTypeSupported>>,
    key_provider: &dyn KeyProvider,
    key_algorithm_provider: &dyn KeyAlgorithmProvider,
    key_security_level_provider: &dyn KeySecurityLevelProvider,
) -> Result<PickedKeyConfig, IssuanceProtocolError> {
    let issuer_proof_config = proof_types_supported
        .as_ref()
        .and_then(|proof_types| proof_types.get("jwt"));

    let issuer_accepted_key_storage_security_levels = issuer_proof_config
        .and_then(|proof_type| {
            proof_type
                .key_attestations_required
                .as_ref()
                .map(|kar| &kar.key_storage)
        })
        .and_then(|levels| (!levels.is_empty()).then_some(levels));

    let issuer_accepted_algorithms = issuer_proof_config.map(|proof_type| {
        proof_type
            .proof_signing_alg_values_supported
            .iter()
            .filter_map(|alg| key_algorithm_provider.key_algorithm_from_jose_alg(alg))
            .map(|(alg, _)| alg)
            .collect::<Vec<_>>()
    });

    for (_, security_level) in key_security_level_provider.ordered_by_priority() {
        if issuer_accepted_key_storage_security_levels
            .as_ref()
            .is_some_and(|issuer_accepted_levels| {
                !security_level
                    .get_capabilities()
                    .openid_security_level
                    .iter()
                    .any(|level| issuer_accepted_levels.contains(level))
            })
        {
            continue;
        }

        for key_storage_id in security_level.get_key_storages() {
            let Some(storage) = key_provider.get_key_storage(key_storage_id) else {
                continue;
            };

            for (algorithm, _) in key_algorithm_provider.ordered_by_holder_priority() {
                if !storage.get_capabilities().algorithms.contains(&algorithm) {
                    continue;
                }

                if let Some(issuer_accepted_algorithms) = &issuer_accepted_algorithms
                    && !issuer_accepted_algorithms.contains(&algorithm)
                {
                    continue;
                }

                return Ok(PickedKeyConfig {
                    key_storage_id: key_storage_id.to_owned(),
                    key_storage: storage,
                    key_algorithm: algorithm,
                });
            }
        }
    }

    Err(IssuanceProtocolError::BindingAutogenerationFailure(
        format!(
            "Could not find a proper key storage, issuer_accepted_key_storage_security_levels:{issuer_accepted_key_storage_security_levels:?}, issuer_accepted_algorithms:{issuer_accepted_algorithms:?}"
        ),
    ))
}

use indexmap::{IndexSet, indexset};
use url::Url;

use crate::provider::credential_formatter::model::{Context, CredentialSchema};
use crate::provider::credential_formatter::vcdm::ContextType;

pub fn vcdm_v1_base_context(
    additional_contexts: Option<Vec<ContextType>>,
) -> IndexSet<ContextType> {
    let mut result = indexset![
        ContextType::Url(Context::CredentialsV1.to_url()),
        ContextType::Url(Context::BitstringStatusList.to_url()),
        ContextType::Url(Context::DataIntegrityV2.to_url()),
    ];

    if let Some(additional_contexts) = additional_contexts {
        result.extend(additional_contexts);
    }

    result
}

pub fn vcdm_v2_base_context(
    additional_contexts: Option<Vec<ContextType>>,
) -> IndexSet<ContextType> {
    let mut result = indexset![ContextType::Url(Context::CredentialsV2.to_url())];

    if let Some(additional_contexts) = additional_contexts {
        result.extend(additional_contexts);
    }
    result
}

pub fn vcdm_type(additional_types: Option<Vec<String>>) -> Vec<String> {
    let mut types = vec!["VerifiableCredential".to_string()];
    if let Some(additional_types) = additional_types {
        types.extend(additional_types);
    };
    types
}

pub static DEFAULT_ALLOWED_CONTEXTS: [&str; 4] = [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/2018/credentials/v1",
    "https://w3c.github.io/vc-bitstring-status-list/contexts/v1.jsonld",
    "https://w3id.org/security/data-integrity/v2",
];

pub fn is_context_list_valid(
    context_list: &IndexSet<ContextType>,
    allowed_contexts: Option<&Vec<Url>>,
    default_allowed_contexts: &[&str],
    credential_schemas: Option<&Vec<CredentialSchema>>,
    credential_id: Option<&Url>,
) -> bool {
    for context in context_list {
        match context {
            ContextType::Url(url) => {
                // Phase one - match against context list
                match allowed_contexts {
                    Some(provided) => {
                        if provided.contains(url) {
                            continue;
                        }
                    }
                    // Check defaults if required are not provided
                    None => {
                        if default_allowed_contexts.contains(&url.as_str()) {
                            continue;
                        }
                    }
                }

                // Phase two - match with available credential schemas
                if let Some(schemas) = credential_schemas {
                    if schemas.iter().any(|schema| {
                        let jsonld_context =
                            schema.id.replace("/ssi/schema/v1/", "/ssi/context/v1/");

                        // Workaround for lvvc context
                        let (base_url, _) =
                            schema.id.split_once("/ssi/schema/v1/").unwrap_or_default();
                        let lvvc_context = format!("{base_url}/ssi/context/v1/lvvc.json");

                        jsonld_context == url.as_str() || lvvc_context == url.as_str()
                    }) {
                        continue;
                    }
                }

                // Phase three - workaround for lvvc. When LVVC context
                // is hosted somewhere this can be removed.
                if let Some(id) = credential_id {
                    let (base_url, _) = id.as_str().split_once("/ssi/lvvc/v1/").unwrap_or_default();
                    let lvvc_context = format!("{base_url}/ssi/context/v1/lvvc.json");
                    if lvvc_context == url.as_str() {
                        continue;
                    }
                }
            }
            ContextType::Object(_) => continue, // Nothing to do
        }

        // If we could not match it with any allowed context bail here
        return false;
    }

    // All contexts whitelisted
    true
}

// These terms are defined in the default w3c contexts
// We automatically include definitions for all claims in our autogenerated contexts
// including these terms in our JSON-LD documents will lead to term redefinition errors
//
pub fn jsonld_forbidden_claim_names() -> Vec<String> {
    [
        "confidenceMethod",
        "credentialSchema",
        "credentialStatus",
        "credentialSubject",
        "description",
        "digestMultibase",
        "digestSRI",
        "evidence",
        "id",
        "issuer",
        "mediaType",
        "name",
        "proof",
        "refreshService",
        "relatedResource",
        "renderMethod",
        "termsOfUse",
        "type",
        "validFrom",
        "validUntil",
    ]
    .map(str::to_string)
    .to_vec()
}
